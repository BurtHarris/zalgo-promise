{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7a7bbc4f7c22fd8e3d76","webpack:///./src/utils.js","webpack:///./src/global.js","webpack:///./src/promise.js","webpack:///./src/exceptions.js","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isPromise","item","Promise","window","Window","constructor","toString","then","err","getGlobal","glob","global","TypeError","zalgoGlobal","__zalgopromise__","flushPromises","activeCount","possiblyUnhandledPromiseHandlers","dispatchedErrors","ZalgoPromise","handler","_this","_classCallCheck","resolved","rejected","errorHandled","handlers","result","error","isAsync","res","resolve","reject","Error","value","dispatch","_this2","setTimeout","promise","indexOf","push","j","length","dispatchPossiblyUnhandledError","asyncReject","_this3","dispatching","_loop","_handlers$i","onSuccess","onError","flushQueue","undefined","onFinally","timeout","time","_this4","clearTimeout","toPromise","all","promises","count","results","_loop2","prom","hash","keys","map","key","items","method","onPossiblyUnhandledException","cancel","splice","context","args","apply","delay","flush","promisesToFlush","_i2","_length2","__webpack_exports__","promise_ZalgoPromise"],"mappings":"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","file":"zalgo-promise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ZalgoPromise\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZalgoPromise\"] = factory();\n\telse\n\t\troot[\"ZalgoPromise\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7a7bbc4f7c22fd8e3d76","/* @flow */\n\nexport function isPromise(item : mixed) : boolean {\n    try {\n        if (!item) {\n            return false;\n        }\n\n        if (typeof Promise !== 'undefined' && item instanceof Promise) {\n            return true;\n        }\n\n        if (typeof window !== 'undefined' && window.Window && item instanceof window.Window) {\n            return false;\n        }\n\n        if (typeof window !== 'undefined' && window.constructor && item instanceof window.constructor) {\n            return false;\n        }\n\n        let toString = ({}).toString;\n\n        if (toString) {\n            let name = toString.call(item);\n\n            if (name === '[object Window]' || name === '[object global]' || name === '[object DOMWindow]') {\n                return false;\n            }\n        }\n\n        if (typeof item.then === 'function') {\n            return true;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","/* @flow */\n\nimport type { ZalgoPromise } from './promise';\n\ntype ZalgoGlobalType = {\n    flushPromises : Array<ZalgoPromise<mixed>>,\n    activeCount : number,\n    possiblyUnhandledPromiseHandlers : Array<<T>(mixed, ZalgoPromise<T>) => void>, // eslint-disable-line no-undef\n    dispatchedErrors : Array<mixed>\n};\n\nexport function getGlobal() : ZalgoGlobalType {\n\n    let glob;\n\n    if (typeof window !== 'undefined') {\n        glob = window;\n    } else if (typeof global !== 'undefined') {\n        glob = global;\n    } else {\n        throw new TypeError(`Can not find global`);\n    }\n\n    let zalgoGlobal = glob.__zalgopromise__ = glob.__zalgopromise__ || {};\n    zalgoGlobal.flushPromises = zalgoGlobal.flushPromises || [];\n    zalgoGlobal.activeCount = zalgoGlobal.activeCount || 0;\n    zalgoGlobal.possiblyUnhandledPromiseHandlers = zalgoGlobal.possiblyUnhandledPromiseHandlers || [];\n    zalgoGlobal.dispatchedErrors = zalgoGlobal.dispatchedErrors || [];\n\n    return zalgoGlobal;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/global.js","/* @flow */\n\nimport { isPromise } from './utils';\nimport { onPossiblyUnhandledException, dispatchPossiblyUnhandledError } from './exceptions';\nimport { getGlobal } from './global';\n\nexport class ZalgoPromise<R : mixed> {\n\n    resolved : boolean\n    rejected : boolean\n    errorHandled : boolean\n    value : R\n    error : mixed\n    handlers : Array<{\n        promise : ZalgoPromise<*>,\n        onSuccess : void | (result : R) => mixed,\n        onError : void | (error : mixed) => mixed\n    }>\n    dispatching : boolean\n    stack : string\n\n    constructor(handler : ?(resolve : (result : R) => void, reject : (error : mixed) => void) => void) {\n\n        this.resolved = false;\n        this.rejected = false;\n        this.errorHandled = false;\n\n        this.handlers = [];\n\n        if (handler) {\n\n            let result;\n            let error;\n            let resolved = false;\n            let rejected = false;\n            let isAsync = false;\n\n            try {\n                handler(res => {\n                    if (isAsync) {\n                        this.resolve(res);\n                    } else {\n                        resolved = true;\n                        result = res;\n                    }\n\n                }, err => {\n                    if (isAsync) {\n                        this.reject(err);\n                    } else {\n                        rejected = true;\n                        error = err;\n                    }\n                });\n\n            } catch (err) {\n                this.reject(err);\n                return;\n            }\n\n            isAsync = true;\n\n            if (resolved) {\n                // $FlowFixMe\n                this.resolve(result);\n            } else if (rejected) {\n                this.reject(error);\n            }\n        }\n\n        if (__DEBUG__) {\n            try {\n                throw new Error(`ZalgoPromise`);\n            } catch (err) {\n                this.stack = err.stack;\n            }\n        }\n    }\n\n    resolve(result : R) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(result)) {\n            throw new Error('Can not resolve promise with another promise');\n        }\n\n        this.resolved = true;\n        this.value = result;\n        this.dispatch();\n\n        return this;\n    }\n\n    reject(error : mixed) : ZalgoPromise<R> {\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        if (isPromise(error)) {\n            throw new Error('Can not reject promise with another promise');\n        }\n\n        if (!error) {\n            let err = (error && typeof error.toString === 'function' ? error.toString() : Object.prototype.toString.call(error));\n            error = new Error(`Expected reject to be called with Error, got ${ err }`);\n        }\n\n        this.rejected = true;\n        this.error = error;\n\n        if (!this.errorHandled) {\n            setTimeout(() => {\n                if (!this.errorHandled) {\n                    dispatchPossiblyUnhandledError(error, this);\n                }\n            }, 1);\n        }\n\n        this.dispatch();\n\n        return this;\n    }\n\n    asyncReject(error : mixed) : ZalgoPromise<R> {\n        this.errorHandled = true;\n        this.reject(error);\n        return this;\n    }\n\n    // eslint-disable-next-line complexity\n    dispatch() {\n\n        let { dispatching, resolved, rejected, handlers } = this;\n\n        if (dispatching) {\n            return;\n        }\n\n        if (!resolved && !rejected) {\n            return;\n        }\n\n        this.dispatching = true;\n        getGlobal().activeCount += 1;\n\n        for (let i = 0; i < handlers.length; i++) {\n\n            let { onSuccess, onError, promise } = handlers[i];\n\n            let result;\n\n            if (resolved) {\n\n                try {\n                    result = onSuccess ? onSuccess(this.value) : this.value;\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n\n            } else if (rejected) {\n\n                if (!onError) {\n                    promise.reject(this.error);\n                    continue;\n                }\n\n                try {\n                    result = onError(this.error);\n                } catch (err) {\n                    promise.reject(err);\n                    continue;\n                }\n            }\n\n            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n\n                if (result.resolved) {\n                    promise.resolve(result.value);\n                } else {\n                    promise.reject(result.error);\n                }\n\n                result.errorHandled = true;\n\n            } else if (isPromise(result)) {\n\n                if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {\n                    if (result.resolved) {\n                        promise.resolve(result.value);\n                    } else {\n                        promise.reject(result.error);\n                    }\n\n                } else {\n                    // $FlowFixMe\n                    result.then(res => {\n                        promise.resolve(res);\n                    }, err => {\n                        promise.reject(err);\n                    });\n                }\n\n            } else {\n\n                promise.resolve(result);\n            }\n        }\n\n        handlers.length = 0;\n        this.dispatching = false;\n        getGlobal().activeCount -= 1;\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n    }\n\n    then<X : mixed, Y : mixed>(onSuccess : void | (result : R) => (ZalgoPromise<X> | Y), onError : void | (error : mixed) => (ZalgoPromise<X> | Y)) : ZalgoPromise<X | Y> {\n\n        if (onSuccess && typeof onSuccess !== 'function' && !onSuccess.call) {\n            throw new Error('Promise.then expected a function for success handler');\n        }\n\n        if (onError && typeof onError !== 'function' && !onError.call) {\n            throw new Error('Promise.then expected a function for error handler');\n        }\n\n        let promise : ZalgoPromise<X | Y> = new ZalgoPromise();\n\n        this.handlers.push({\n            promise,\n            onSuccess,\n            onError\n        });\n\n        this.errorHandled = true;\n\n        this.dispatch();\n\n        return promise;\n    }\n\n    catch<X : mixed, Y : mixed>(onError : (error : mixed) => ZalgoPromise<X> | Y) : ZalgoPromise<X | Y> {\n        return this.then(undefined, onError);\n    }\n\n    finally(onFinally : () => mixed) : ZalgoPromise<R> {\n\n        if (onFinally && typeof onFinally !== 'function' && !onFinally.call) {\n            throw new Error('Promise.finally expected a function');\n        }\n\n        return this.then((result) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    return result;\n                });\n        }, (err) => {\n            return ZalgoPromise.try(onFinally)\n                .then(() => {\n                    throw err;\n                });\n        });\n    }\n\n    timeout(time : number, err : ?Error) : ZalgoPromise<R> {\n\n        if (this.resolved || this.rejected) {\n            return this;\n        }\n\n        let timeout = setTimeout(() => {\n\n            if (this.resolved || this.rejected) {\n                return;\n            }\n\n            this.reject(err || new Error(`Promise timed out after ${ time }ms`));\n\n        }, time);\n\n        return this.then(result => {\n            clearTimeout(timeout);\n            return result;\n        });\n    }\n\n    // $FlowFixMe\n    toPromise() : Promise<R> {\n        // $FlowFixMe\n        if (typeof Promise === 'undefined') {\n            throw new TypeError(`Could not find Promise`);\n        }\n        // $FlowFixMe\n        return Promise.resolve(this); // eslint-disable-line compat/compat\n    }\n\n    static resolve<X : mixed>(value : X | ZalgoPromise<X>) : ZalgoPromise<X> {\n\n        if (value instanceof ZalgoPromise) {\n            return value;\n        }\n\n        if (isPromise(value)) {\n            // $FlowFixMe\n            return new ZalgoPromise((resolve, reject) => value.then(resolve, reject));\n        }\n\n        return new ZalgoPromise().resolve(value);\n    }\n\n    static reject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().reject(error);\n    }\n\n    static asyncReject(error : mixed) : ZalgoPromise<R> {\n        return new ZalgoPromise().asyncReject(error);\n    }\n\n    static all<X : [*] | [*, *] | [*, *, *] | [*, *, *, *] | [*, *, *, *, *] | [*, *, *, *, *, *] | [*, *, *, *, *, *, *] | [*, *, *, *, *, *, *, *] | [*, *, *, *, *, *, *, *, *] | Array<mixed>>(promises : X) : ZalgoPromise<$TupleMap<X, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n\n        let promise = new ZalgoPromise();\n        let count = promises.length;\n        let results = [];\n\n        if (!count) {\n            promise.resolve(results);\n            return promise;\n        }\n\n        for (let i = 0; i < promises.length; i++) {\n            let prom = promises[i];\n\n            if (prom instanceof ZalgoPromise) {\n                if (prom.resolved) {\n                    results[i] = prom.value;\n                    count -= 1;\n                    continue;\n                }\n            } else if (!isPromise(prom)) {\n                results[i] = prom;\n                count -= 1;\n                continue;\n            }\n\n            ZalgoPromise.resolve(prom).then(result => {\n                results[i] = result;\n                count -= 1;\n                if (count === 0) {\n                    promise.resolve(results);\n                }\n            }, err => {\n                promise.reject(err);\n            });\n        }\n\n        if (count === 0) {\n            promise.resolve(results);\n        }\n\n        return promise;\n    }\n\n    static hash<O : { [string] : * }>(promises : O) : ZalgoPromise<$ObjMap<O, <Y>(ZalgoPromise<Y> | Y) => Y>> { // eslint-disable-line no-undef\n        let result = {};\n        \n        return ZalgoPromise.all(Object.keys(promises).map(key => {\n            return ZalgoPromise.resolve(promises[key]).then(value => {\n                result[key] = value;\n            });\n        })).then(() => {\n            return result;\n        });\n    }\n\n    static map<T, X>(items : Array<T>, method : (T) => (ZalgoPromise<X> | X)) : ZalgoPromise<Array<X>> {\n        // $FlowFixMe\n        return ZalgoPromise.all(items.map(method));\n    }\n\n    static onPossiblyUnhandledException(handler : (err : mixed) => void) : { cancel : () => void } {\n        return onPossiblyUnhandledException(handler);\n    }\n\n    static try<X : mixed, Y : mixed, C : mixed, A : Array<mixed>>(method : (...args : A) => (ZalgoPromise<X> | Y), context : ?C, args : ?A) : ZalgoPromise<X | Y> {\n\n        if (method && typeof method !== 'function' && !method.call) {\n            throw new Error('Promise.try expected a function');\n        }\n\n        let result;\n        \n        try {\n            // $FlowFixMe\n            result = method.apply(context, args || []);\n        } catch (err) {\n            return ZalgoPromise.reject(err);\n        }\n\n        return ZalgoPromise.resolve(result);\n    }\n\n    static delay(delay : number) : ZalgoPromise<void> {\n        return new ZalgoPromise(resolve => {\n            setTimeout(resolve, delay);\n        });\n    }\n\n    static isPromise(value : mixed) : boolean {\n\n        if (value && value instanceof ZalgoPromise) {\n            return true;\n        }\n\n        return isPromise(value);\n    }\n\n    static flush() : ZalgoPromise<void> {\n        let promise = new ZalgoPromise();\n        getGlobal().flushPromises.push(promise);\n\n        if (getGlobal().activeCount === 0) {\n            ZalgoPromise.flushQueue();\n        }\n\n        return promise;\n    }\n\n    static flushQueue() {\n        let promisesToFlush = getGlobal().flushPromises;\n        getGlobal().flushPromises = [];\n\n        for (let promise of promisesToFlush) {\n            promise.resolve();\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/promise.js","/* @flow */\n\nimport { getGlobal } from './global';\nimport type { ZalgoPromise } from './promise';\n\nexport function dispatchPossiblyUnhandledError<T>(err : mixed, promise : ZalgoPromise<T>) {\n\n    if (getGlobal().dispatchedErrors.indexOf(err) !== -1) {\n        return;\n    }\n\n    getGlobal().dispatchedErrors.push(err);\n\n    setTimeout(() => {\n        if (__DEBUG__) {\n            // $FlowFixMe\n            throw new Error(`${ err.stack || err.toString() }\\n\\nFrom promise:\\n\\n${ promise.stack }`);\n        }\n\n        throw err;\n    }, 1);\n\n    for (let j = 0; j < getGlobal().possiblyUnhandledPromiseHandlers.length; j++) {\n        getGlobal().possiblyUnhandledPromiseHandlers[j](err, promise);\n    }\n}\n\nexport function onPossiblyUnhandledException(handler : (mixed) => void) : { cancel : () => void } {\n    getGlobal().possiblyUnhandledPromiseHandlers.push(handler);\n\n    return {\n        cancel() {\n            getGlobal().possiblyUnhandledPromiseHandlers.splice(getGlobal().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n        }\n    };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/exceptions.js","/* @flow */\n\nexport { ZalgoPromise } from './promise';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}